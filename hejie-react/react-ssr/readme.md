## react服务端渲染总结

- 概述
> 其他概念性的东西就不解释了，服务端渲染可以解决seo问题，因为爬虫它不会去跑脚本，如果直接用框架在客户端渲染，那么爬虫它是爬取不到节点的，这不利于seo，所以ssr同构就是为了解决这些问题，同时服务端渲染也可以减少白屏时间提升体验，因为在服务端这边就把节点都涂过来了,这样首屏直接爬虫能爬取到数据，同时，到了客户端后一切就走客户端框架的逻辑了，这是同构


- 常用优秀的框架
> vue语言系的：Nuxt,个人感觉体验极好，约定优于配置很方便开发
react系的： Next
angular: Nest
不采用语言框架的：像以前框架还没盛行的时候，更多是用模板引擎涂过来的，我个人做过的一些项目都是用xtpl服务端渲染的，直接就在服务端处理数据然后模板语言涂好模板，在客户端就多个entry弄成多页面应用也是以前服务端渲染的一种常用手段


- 主要关键过程
1. 注水
原本在客户端的render转成hydrate，在服务端注入，要再服务端渲染模板就意味着服务端这边也要babel的支持，hydrate这个注入的时候如果报dont expect content ... in .. 什么的时候说明你数据什么的或者组件渲染的时候出错了，这时候应该做的是检查你的组件而不是傻傻去检查这个api为什么会报这些错

2. 解析相应路由渲染相应组件
关键就是react-router-dom啦，自己看官网就可以知道用法的，用StaticRouter代替BrowserRouter
https://www.npmjs.com/package/react-router-dom
同时跟组件也要转而变成路由配置的，这点很和纯模板引擎做服务端渲染时webpack打包时配置多入口页面相似
然后路由用法其实就和平时的一样了，用provider传store什么的都一样，没什么好说的

3. store
就同构的话store是分服务端和客户端的，因为爬虫要在服务端爬到异步数据的话，这个store就得分开服务端，客户端两个store了，首屏时服务端初始化store，然后再客户端时直接填充给客户端，nuxt做的也是同样的事，nuxtServerInit，fetch这些钩子做的事也是在服务端初始化，然后到客户端时直接再填充给客户端

4. 接口反代
事实上大圣老师提出的第二个作业就是代理接口，跨域是浏览器才会搞出来的问题，服务器请求是不会跨域的，所以我们把所有请求都跑到我们这个服务上去代发，在服务nuxt配置文件有个proxyTable，做的就是这事，然后现在也有很多成熟的中间件了做的也就是这件事，http-proxy-middleware之类，或者axios直接配置请求源也可以做到，用nginx转代也都可以解决跨域了

5. promise.all异常不中断的
我是promise数组都各自catch捕获异常的，这样异常不会抛到最上层就不会终止这个过程了

- 实践
> 这几节课程其实基本都可以搞清楚服务端渲染是怎样一个过程了，但怎么结合框架应用，怎么应用在现有项目是需要自己去尝试的
> 事实上，现有成熟框架都可以帮我们很好地做这些服务端渲染的工作了，store的传递上下文的传递工具都帮我们做了，用框架的话，需要我们做的多是加深对服务端渲染这个概念的理解，以及在server层封装自己的中间件，加深对node后端的理解和应用，理解了整个过程为主，理解之后再应用框架工具，工具是帮我们做事省时间的，纸上谈兵终究没用



